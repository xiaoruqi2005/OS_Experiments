# 实验报告四：中断处理与时钟管理

## 1 实验目标
本实验旨在深入理解操作系统与硬件交互的核心机制——中断与异常。基于 RISC-V 特权级架构，设计并实现一个功能完备的内核中断处理子系统。具体目标包括：
1.  **掌握RISC-V中断架构：** 理解 M 模式与 S 模式的协作关系，掌握 `stvec`、`scause`、`sepc` 等关键 CSR 寄存器的作用与配置。
2.  **实现中断委托机制：** 通过配置 `medeleg` 和 `mideleg`，实现将时钟、软件及外部中断委托给 S 模式内核直接处理。
3.  **构建上下文切换系统：** 编写汇编代码实现中断发生时的寄存器现场保存（Save Context）与恢复（Restore Context）。
4.  **实现时钟与异常处理：** 搭建基于“注册-分发”模式的中断处理框架，实现时钟驱动的时间管理，以及针对非法指令、页错误等异常的保护性处理。

---

## 2 实验内容

### 2.1 任务1-2：理解RISC-V中断架构与初始化
#### 2.1.1 特权级与委托机制
RISC-V 架构中，硬件中断（如时钟）默认由机器模式（M-mode）捕获。为了让运行在监督模式（S-mode）的操作系统能高效处理中断，我们需要利用 **委托（Delegation）** 机制。

* **异常委托 (`medeleg`):** 设置为 `0xffff`，将所有同步异常（如系统调用、断点、缺页）交给 S 模式。
* **中断委托 (`mideleg`):** 使能 `SSIP` (软件中断)、`STIE` (时钟中断) 和 `SEIE` (外部中断) 的委托位。

#### 2.1.2 关键寄存器配置
在 `start.c` 和 `trap_init` 中，我们配置了以下核心寄存器：
* `mstatus.MPP`: 设置为 S 模式，确保 `mret` 后进入内核。
* `stvec`: 指向 S 模式中断向量基址 `kernelvec`。
* `sie`: 开启 S 模式下的各类中断使能。

### 2.2 任务3-4：中断处理框架与上下文切换
#### 2.2.1 上下文保存 (`kernelvec.S`)
中断发生时，硬件不会自动保存通用寄存器。我在汇编层实现了精细的栈操作：
1.  **开辟栈空间：** `addi sp, sp, -264`，为 `trapframe` 预留空间。
2.  **保存寄存器：** 依次保存 32 个通用寄存器。
3.  **保存特殊状态：** 关键步骤是读取并保存 `sepc`（中断返回地址）和 `sstatus`（状态），防止嵌套中断或 C 函数执行导致这些状态丢失。

#### 2.2.2 中断分发器 (`trap.c`)
设计了通用的分发逻辑：
* **统一入口：** `kerneltrap()` 接收 `trapframe` 指针。
* **类型判断：** 通过 `scause` 最高位判断是中断（Interrupt）还是异常（Exception）。
* **注册机制：** 维护 `interrupt_handlers` 函数指针数组，支持动态注册 ISR（如时钟处理函数），提高了系统的扩展性。

### 2.3 任务5：时钟中断的跨特权级驱动
由于 RISC-V 的 `mtime` 硬件资源仅限 M 模式访问，我实现了一套 **“软件注入”** 机制来驱动 S 模式时钟：
1.  **M 模式触发：** 硬件计数器溢出，触发 M 模式 `timervec`。
2.  **注入中断：** M 模式处理程序在重置定时器后，执行 `csrw sip, 2`，人为置位 S 模式软件中断 pending 位。
3.  **S 模式响应：** 内核捕获 `IRQ_S_SOFT`，在逻辑上将其映射为时钟滴答（Tick），更新系统时间 `uptime`。

### 2.4 任务6：异常处理与系统保护
针对同步异常，实施了分级处理策略：
* **可恢复异常（如 Breakpoint）：** 打印提示后，执行 `tf->sepc += 2` 跳过指令，让系统继续运行。
* **致命错误（如 Page Fault）：** 鉴于当前未实现进程隔离，对于非法内存访问，采取 **Panic（死机）** 策略，打印详细的 `stval`（出错地址）和 `sepc`（指令地址）后挂起系统，防止错误扩散导致数据损坏。

---

## 3 思考题（原理与分析）

### 3.1 中断设计：为何时钟中断要“转手”？
* ***为什么时钟中断在M模式处理后再委托给S模式？***
    RISC-V 的计时器硬件（CLINT）属于 M 模式资源，S 模式无法直接配置物理时钟的中断触发时间。为了维持特权级隔离，通常由运行在 M 模式的固件（Firmware）管理硬件细节，并通过注入虚拟的中断信号（如设置 `sip` 寄存器）通知 S 模式内核，从而实现硬件抽象。

### 3.2 性能考量：开销与优化
* ***中断处理的时间开销主要在哪里？***
    1.  **寄存器存取：** 保存和恢复 32 个通用寄存器及 CSR 涉及大量的内存读写，且可能导致 Cache Miss。
    2.  **流水线冲刷：** 中断发生会导致 CPU 流水线清空，分支预测失效。
    3.  **模式切换：** 进出内核态可能涉及 TLB 刷新（取决于架构实现）。
* ***如何优化？***
    利用 ABI 规范仅保存 Caller-saved 寄存器；或使用硬件支持的影子寄存器组实现快速切换；以及利用 Trampoline 机制减少页表切换开销。

### 3.3 可靠性：错误处理与安全
* ***中断处理中的错误应该如何处理？***
    * **用户态错误：**（如用户程序除零、非法访问）内核应捕获异常，终止该进程（Kill），回收资源，保证 OS 自身不崩溃。
    * **内核态错误：**（如内核代码空指针）由于系统状态已不可信，应立即执行 **Panic**，打印调试信息并停机，这是最安全的“快速失败”策略。

### 3.4 扩展性与实时性
* ***如何支持更多类型的中断源？***
    采用 **注册表驱动** 的设计。维护一个以中断号为索引的函数指针数组，新增设备只需调用 `register_interrupt` 接口绑定 ISR，无需修改核心分发逻辑。
* ***如何设计满足实时要求的中断系统？***
    必须支持 **抢占式内核** 和 **中断嵌套**，允许高优先级事件打断低优先级处理。同时，需要严格限制内核中“关中断临界区”的最长执行时间，确保中断响应延迟（Latency）是可预测且有界的。

---

## 4 实验总结
通过本次实验，我成功打通了从底层硬件中断到上层 C 语言处理函数的完整链路。
最深刻的体会在于理解 **“上下文”** 的概念——不仅是通用寄存器，还包括 `sepc` 和 `sstatus` 等特权级状态。在调试过程中，曾因未保存 `sstatus` 导致中断返回后权限错误，这让我意识到操作系统内核开发的严谨性。此外，通过实现时钟中断的软件注入机制，我深入理解了 RISC-V 架构中 Firmware 与 OS 的协作模式，为后续实现抢占式调度打下了坚实基础。
