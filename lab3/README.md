# 实验报告三：页表与内存管理
## 1 实验目标
本实验旨在深入理解现代操作系统中虚拟内存管理的核心机制。通过分析xv6-riscv的内存管理源码，并基于RISC-V Sv39分页规范，独立设计并实现一个简化的内核级内存管理系统。具体目标包括：
1. **理解物理内存管理：** 掌握物理内存的布局、发现与组织方式，实现一个基于空闲链表的物理页分配器。
2. **掌握Sv39页表机制：** 理解RISC-V三级页表的地址转换原理、页表项（PTE）的结构与权限位作用。
3. **实现页表管理系统：** 编码实现页表的创建、虚拟地址到物理地址的映射、以及页表的激活。
4. **构建内核地址空间：** 为内核创建页表，完成内核代码、数据、设备等关键区域的映射，并成功启用分页。

---
## 2 实验内容
### 2.1 任务1-2：深入理解Sv39页表与xv6物理内存分配器
#### 2.1.1 分析Sv39三级页表机制：
* ***39位虚拟地址的分解：*** 
  
  RISC-V Sv39模式下的虚拟地址被分为四个部分：
  ```text 
  38       30 29       21 20       12 11        0
  | VPN[2] |  | VPN[1] |  | VPN[0] |  |  offset  |
  ```
  * **VPN[2], VPN[1], VPN[0]：** 各占9位，分别作为三级、二级、一级页表的索引，每个索引可以在512个页表项（PTE）中选择一个。
  * **offset：** 占12位，用于在最终的4KB物理页内进行寻址。
  * **为什么是9位？** 因为页表本身也是一个物理页（4KB），而每个PTE占8字节，所以一个页表页可以存放 `4096 / 8 = 512 `个PTE。`2^9 = 512`，因此9位索引刚好可以完整地索引一个页表页。
* ***页表项（PTE）格式理解：*** 
  
  PTE是一个64位的结构，其中最重要的标志位包括：
  * **V (Valid):** 若为1，表示此PTE有效，其指向的物理地址是合法的。
  * **R/W/X (Read/Write/Execute):** 控制对该页面的读、写、执行权限。
  * **U (User):** 若为1，表示用户模式（U-mode）可以访问该页，否则只有监督模式（S-mode）可以访问。
  * **PPN (Physical Page Number):** 存储物理页号，与页内偏移（offset）组合成最终的物理地址。
* ***深入思考：*** 
  
  * **为什么选择三级页表？** 这是空间效率与转换效率的权衡。一级页表太大（需要GB级别连续内存），多级页表则可以用时间（多次访存）换空间，只为实际使用的地址分配页表页，大大节省了内存。三级页表在39位地址空间下提供了合适的粒度。
  * **"页表也存储在物理内存中"如何理解？** 页表本身不是特殊的硬件结构，它就是存储在RAM中的普通数据。CPU的MMU硬件根据`satp`寄存器找到根页表的物理地址，然后像访问普通内存一样逐级读取PTE，最终计算出目标物理地址。

#### 2.1.2 分析xv6的物理内存分配器 (kalloc.c)：
* ***核心数据结构`struct run`的设计巧妙之处：*** 
  ```cpp {.line-numbers}
  struct run {
    struct run *next;
  };
  ```
  这个设计的核心是 **“就地取材”**。它将空闲的物理页本身当作链表节点来使用。当一个物理页被释放时，`kfree`会把它强制转换为`struct run*`类型，并将其`next`指针指向当前的空闲链表头。这样不需要为链表节点额外分配任何元数据空间，极大地简化了设计并节约了内存。
* ***`kinit()`、`kalloc()`和`kfree()`的实现：*** 
  
  * **`kinit()`:** 初始化函数。它从链接脚本提供的`_end`符号（内核静态部分的结束地址）开始，到`PHYSTOP`（物理内存顶端）结束，逐个物理页调用`kfree()`，将所有可用的物理内存都加入到空闲链表中。
  * **`kalloc()`:** 分配函数。它从空闲链表`（kmem.freelist）`的头部取下一个节点（一个空闲页），更新链表头，然后返回这个页的地址。这是一个非常高效的`O(1)`操作。
  * **`kfree()`:** 释放函数。它接收一个物理页地址，将其转换为`struct run*`，然后将其插入到空闲链表的头部。这也是一个`O(1)`操作。


### 2.2 任务3-6：设计并实现页表与内存管理
#### 2.2.1 实验原理与设计
* **系统架构**
  
  本次实验我们构建了一个精简但完整的内存管理系统，由以下模块组成：
  1. **启动模块 (entry.S, start.c):** 负责从M-mode切换到S-mode，并为内核设置初始栈和PMP，为后续内存操作提供安全的环境。
  2. **物理内存分配器 (kalloc.c):** 管理从end到PHYSTOP的物理内存，提供kalloc()和kfree()接口。
  3. **虚拟内存管理器 (vm.c):** 实现RISC-V Sv39页表操作，提供mappages接口用于建立映射，并提供kvminit和kvminithart来创建和激活内核页表。
  4. **主控模块 (main.c):** 协调调用以上模块的初始化函数，并在初始化完成后执行分层测试，验证系统的正确性。

* **与xv6设计的异同分析**
  **1. 相同点：**
    * **核心算法一致:** 完全采用了xv6的空闲链表物理内存分配算法和三级页表遍历映射算法。
    * **启动流程相似:** 遵循entry.S -> start.c -> main.c的启动顺序，并完成了M-mode到S-mode的切换。
    * **内存布局一致:** 遵循QEMU virt机器的内存布局，将内核加载在0x80000000。
  
  **2. 不同点：**
    * **极度简化:** 省略了xv6中与进程、文件系统、锁相关的复杂代码，只保留了内存管理的核心逻辑。例如，我们的kalloc和kfree没有加锁，因为当前是单核环境且未调度进程。
    * **无用户空间:** 我们的页表只为内核创建了映射，没有涉及用户地址空间、trap处理等复杂机制。
    * **增加了显式测试:** 在main.c中加入了分层测试代码，这是xv6源码中所没有的，旨在教学和验证。


#### 2.2.2 实验步骤与实现

**1. 实验步骤记录**

**阶段一：修正启动流程**
  1. 创建`start.c`文件，实现从M-mode到S-mode的切换逻辑，并正确配置PMP。
  2. 重写`entry.S`，使其使用`start.c`中定义的静态栈，并调用`start()`函数。
  3. 更新`Makefile`和`riscv.h`，添加新文件和必需的CSR操作函数。

**阶段二：实现物理内存管理**  
  1. 创建`kalloc.c`，实现基于`struct run`的空闲链表。
  2. 实现`kinit()`，将`end`到`PHYSTOP`之间的所有物理内存页加入空闲链表。
  3. 实现`kalloc()`和`kfree()`，用于分配和释放物理页。

**阶段三：实现虚拟内存管理**
  1. 创建`vm.c`，实现`walk()`函数，用于遍历三级页表并找到指定虚拟地址的PTE。
  2. 实现`mappages()`函数，用于将一段虚拟地址连续地映射到一段物理地址。
  3. 实现`kvminit()`，分配根页表，并调用`mappages`完成内核代码段、数据段和UART的映射。
  4. 实现`kvminithart()`，将根页表的物理地址写入`satp`寄存器并刷新TLB，正式启用分页。

**阶段四：集成与测试**
  1. 在`main.c`中按顺序调用`kinit`, `kvminit`, `kvminithart`。
  2. 编写并加入`test_physical_memory`, `test_pagetable`, `test_virtual_memory`三个分层测试函数。
  3. 编译并运行，观察测试结果是否全部通过。

**2. 核心关键代码理解总结**

* **关键代码1：M-mode到S-mode的切换 (start.c)** 
  这是内核能接管硬件的前提。通过配置`mstatus`、`mepc`和执行`mret`指令，CPU的权限级别从机器模式降至监督模式，并将控制权交给了`main`函数。同时，配置PMP是解决内存访问异常的关键。
  ```cpp {.line-numbers}
  // ... 配置 mstatus, mepc, deleg ...
  // 配置PMP，允许S-mode访问所有物理内存
  w_pmpaddr0(0x3fffffffffffffull);
  w_pmpcfg0(0xf); // 授予R,W,X权限
  // 切换到Supervisor模式
  asm volatile("mret");
  ```

* **关键代码2：页表遍历函数 `walk()` (vm.c)** 
  这是虚拟地址转换的核心。它通过位运算从虚拟地址中逐级提取9位索引，在三级页表中“行走”，最终找到叶子PTE。`alloc`参数的设计非常巧妙，使得该函数既可用于查询，也可用于创建页表项。
  ```c {.line-numbers}
  pte_t* walk(pagetable_t pagetable, uint64 va, int alloc) {
    for(int level = 2; level > 0; level--) {
      pte_t *pte = &pagetable[PX(level, va)]; // PX宏提取索引
      if(*pte & PTE_V) {
        pagetable = (pagetable_t)PTE2PA(*pte);
      } else {
        if(!alloc || (pagetable = (pagetable_t)kalloc()) == 0)
          return 0; // 分配失败
        memset(pagetable, 0, PGSIZE);
        *pte = PA2PTE(pagetable) | PTE_V; // 创建新页表页
      }
    }
    return &pagetable[PX(0, va)]; // 返回叶子PTE地址
  }
  ```

* **关键代码3：内核空间映射 `kvminit() ` (vm.c)** 
  定义了内核启动后自身的“视界”。它将内核的`.text`段映射为可读可执行，将`.data`段和所有物理内存映射为可读可写。特别地，它将UART的物理地址恒等映射到相同的虚拟地址，确保在启用分页后，`printf`依然能通过`0x10000000L`这个地址访问UART寄存器。
  ```c {.line-numbers}
  void kvminit(void) {
    // ...
    // 恒等映射UART
    mappages(kernel_pagetable, UART0, PGSIZE, UART0, PTE_R | PTE_W);
    // 映射内核代码段
    mappages(kernel_pagetable, KERNBASE, (uint64)etext-KERNBASE, KERNBASE, PTE_R | PTE_X);
    // 映射内核数据段及剩余物理内存
    mappages(kernel_pagetable, (uint64)etext, PHYSTOP-(uint64)etext, (uint64)etext, PTE_R | PTE_W);
  }
  ```

#### 2.2.3 实验测试与结果

  * **测试操作：** 终端输入`make`指令进行编译，之后输入`make run`运行，系统启动并自动执行分层测试。终端输出如下：
    ```text
    xv6-riscv-simplified by XXX
    --- Test 1: Physical Memory Allocator ---
    Physical memory test PASSED

    --- Test 2: Page Table Functionality ---
    Page table test PASSED

    --- Test 3: Virtual Memory Activation ---
    Kernel code is executable after enabling paging.
    Kernel data is accessible.
    Device (UART) access is working.
    Virtual memory test PASSED

    ====== All Tests Passed! ======
    Booting complete!
    ```
  * **结果分析：** 
    所有测试均成功通过，证明本次实验实现的内存管理系统正确、有效。
    1. **物理内存测试通过：** 表明`kalloc`能成功分配不同页，`kfree`后内存能被正确回收复用。
    2. **页表功能测试通过：** 表明`walk`和`mappages`能正确创建映射，PTE的权限位设置正确，并且通过映射后的虚拟地址可以成功读写物理内存。
    3. **虚拟内存激活测试通过：** 表明启用分页后，内核页表正确工作。`printf`依然能输出（UART映射成功），内核代码能继续执行（`.text`段映射成功），内核数据能被修改（`.data`段映射成功）。
---
## 3 所遇问题与解决
* **问题1：沿袭第四节的启动结构，导致链接错误与启动流程不兼容**
    * **原因：** 第四节实验的启动代码`(entry.S)`非常简单，它依赖链接脚本提供的 `_end` 符号来动态设置栈顶。然而，第五节实验引入了更复杂的内存模型，并需要一个标准化的启动流程来完成从M-mode到S-mode的切换，旧的 `entry.S` 无法满足这些新需求，导致了 `undefined reference to '_end'` 的链接错误。
    * **解决：** 放弃了 lab2 的启动方式，完全重构为与xv6一致的启动流程。具体步骤是：创建 `start.c` 负责M-mode初始化和模式切换；重写 `entry.S` 以设置静态栈并调用 `start()`；最后更新 `Makefile` 将 `start.c` 加入编译。

* **问题2：`start.c` 编译时出现大量`implicit declaration`和`undefined reference`错误**
  
    * **原因：** `start.c`中使用了`r_mstatus`等读写CPU控制寄存器的函数，但这些函数的内联汇编定义位于`riscv.h`中。最初的`riscv.h`文件内容不完整，缺失了这些关键的函数定义。
    * **解决：** 用一个包含了所有必需的CSR操作函数的完整版本替换了`kernel/riscv.h`文件。

* **问题3：启用分页后，程序在`kinit`中“卡死”**

    * **原因：** 经过`printf`调试，发现程序在`kinit`调用`kfree`，`kfree`调用memset时崩溃。根本原因是在`start.c`中没有配置PMP（物理内存保护），导致S-mode下的内核无权访问`end`符号之后的物理内存，触发了访问异常，而此时系统尚未建立异常处理机制。
    * **解决：** 在`start.c`的`mret`指令前，添加配置`pmpaddr0`和`pmpcfg0`的代码，为S-mode授予对全部物理内存的读、写、执行权限。

---
## 4 思考题
### 4.1 设计对比：
* ***你的物理内存分配器与xv6有什么不同？***
  
  主要不同点在于并发安全。我的实现是一个简化的版本，没有包含任何锁机制。而 xv6 的 `kalloc.c` 中，`kalloc()` 和 `kfree()` 函数在修改全局空闲链表 `kmem.freelist` 之前，都会通过 `acquire(&kmem.lock)` 获取一个自旋锁，操作完成后再通过 `release(&kmem.lock)` 释放锁。
* ***为什么选择这种设计？有什么权衡？***
  
  选择简化设计的原因是为了聚焦本次实验的核心目标——理解内存分配算法和页表机制本身。在单核、无进程调度的早期内核启动阶段，不存在并发访问空闲链表的可能，因此可以安全地省略锁。
  权衡之处在于**通用性 vs 复杂度**。
  * **优点：** 代码更简单，逻辑更清晰，更容易理解物理页分配的核心思想。
  * **缺点：** 这个分配器不是线程安全的。一旦未来内核引入多核支持或中断驱动的并发任务，就必须像 xv6 一样加上锁，否则会导致链表损坏和内存分配错误。

### 4.2 内存安全：
* ***如何防止内存分配器被恶意利用？***
  
  1. **严格的指针检查：** 在 `kfree()` 中，必须严格检查传入的地址 `pa` 是否合法。例如，检查它是否页对齐，是否在可管理的物理内存范围内（`end` 到 `PHYSTOP` 之间）。这可以防止内核的其他部分错误地释放一个无效地址，从而破坏空闲链表。
  2. **隔离内核与用户空间：** 这是最重要的安全机制。内核内存分配器分配的物理页，绝不能直接暴露给用户进程。当用户进程需要内存时，内核应分配物理页，然后通过页表将其映射到用户进程的虚拟地址空间，并设置好权限（如`PTE_U`标志，清除`PTE_W`实现只读等）。
  3. **栈保护:** 虽然与分配器不直接相关，但在函数栈上放置哨兵值可以检测栈溢出，防止恶意代码通过覆盖返回地址来执行攻击。
* ***页表权限设置的安全考虑有哪些？***
  
  1. **最小权限原则：** 内核代码段`（.text）`应映射为只读、可执行`（R-X）`，防止被意外或恶意修改。内核数据段`（.data, .bss）`应映射为可读、可写`（R-W）`，但不可执行，这可以防止代码注入攻击。
  2. **用户/监督模式隔离：** 所有内核空间的映射（代码、数据、页表自身）都不能设置 `PTE_U` 位，确保用户进程无法读取或修改内核内存。
  3. **栈保护页：** 在用户栈或内核栈的底部设置一个无效的页表项（PTE的V位为0）。当发生栈溢出时，访问这个地址会立即触发缺页异常，而不是悄无声息地破坏下方内存。
  4. **写时复制：** 在` fork() `时，父子进程可以共享只读的物理页面。当任何一方尝试写入时，触发缺页异常，内核再为其分配一个新的可写页面副本。这既高效又安全。
  
### 4.3 性能分析：
* ***当前实现的性能瓶颈在哪里？***
  
  1. **物理内存分配：** 虽然`kalloc/kfree`是 `O(1)` 操作，但如果未来系统有大量、频繁的小块内存分配需求（而不是整页分配），这个简单的页分配器会非常低效，并产生大量内部碎片。此时需要更复杂的slab或buddy分配器。
  2. **TLB Miss：** `walk`函数每次进行地址转换都需要三次内存访问（三级页表）。如果程序的内存访问局部性差，会导致大量的TLB未命中，每次都需要MMU硬件或软件重新遍历页表，这将是主要的性能瓶颈。
  
* ***如何测量和优化内存访问性能？***
  
  * **测量：** 可以通过硬件性能计数器来测量TLB Miss的频率、缺页中断的次数等指标。
  * **优化：**
    1.**使用大页：** 对于大块的连续内存区域（如内核自身、帧缓冲），可以使用`2MB`或`1GB`的大页进行映射。一个大页PTE可以直接映射一大块物理内存，减少了页表级数和TLB条目数，从而降低TLB Miss率。
    2. **优化数据结构布局：** 在编程时，有意识地将频繁一起访问的数据放在同一个内存页中，以提高空间局部性。
    3. **预取：** 在访问一个数据前，使用预取指令将可能很快会用到的数据提前加载到缓存中。


---
## 5 实验总结
通过本次实验，我成功地从零开始构建了一个简化的操作系统内核内存管理系统。这不仅是一次编码练习，更是一次对操作系统底层原理的深刻探索。

从最初面对`undefined reference`链接错误的困惑，到通过分析xv6启动流程找到解决方案；从程序在`kinit`中神秘“卡死”，到最终定位到`RISC-V PMP`这一硬件特性，整个过程极大地锻炼了我底层调试和问题分析的能力。

亲手实现`walk`和`mappages`函数让我对虚拟地址如何一步步“翻译”成物理地址有了直观的认识，而配置`satp`寄存器并启用分页的那一刻，则让我真切感受到了操作系统是如何接管硬件内存管理单元的。

本次实验让我将《操作系统》课本上的抽象概念——物理页、页表、地址转换——转化为了看得见、摸得着、能运行的代码，为后续学习更复杂的内核功能（如进程管理和缺页中断）打下了坚实的基础。